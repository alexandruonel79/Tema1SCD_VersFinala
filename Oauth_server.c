/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "Oauth.h"
#include "token.h"
#include "helper_Oauth.h"

request_auth_res *
request_authorization_1_svc(request_authorization_args *argp, struct svc_req *rqstp)
{
	static request_auth_res result;

	char *client_id = argp->user_id;
	if (is_user_in_db(client_id))
	{
		char *auth_token = generate_access_token(client_id);
		// allocate memory for the auth_token
		result.auth_token = malloc(strlen(auth_token) + 1);
		result.error = malloc(MAX_CHAR_SIZE);

		memcpy(result.auth_token, auth_token, strlen(auth_token) + 1);
		memcpy(result.error, "NONE", 5);

		// set the auth token to the user
		int index = get_user_index(client_id);
		memcpy(tokens_global[index].auth_token, auth_token, strlen(auth_token) + 1);
		tokens_global[index].automatic_refresh = argp->auto_renew;
		printf("BEGIN %s AUTHZ\n", client_id);
		printf("  RequestToken = %s\n", auth_token);
		fflush(stdout);
	}
	else
	{
		printf("BEGIN %s AUTHZ\n", client_id);

		memcpy(result.error, "USER_NOT_FOUND", 15);
	}

	return &result;
}

approve_request_token_res *
approve_request_token_1_svc(approve_request_token_args *argp, struct svc_req *rqstp)
{
	static approve_request_token_res result;

	// get the auth token from the client
	char *auth_token = argp->auth_token;
	// get the permissions from the user
	char *files_and_perms = simulate_user_prompt_file_permissions();

	Approvals approvals = create_approvals_from_string(files_and_perms);
	// check if the user has any permission
	if (!user_has_any_permission(approvals))
	{
		// return the auth token unchanged, the data not signed
		result.signed_data.auth_token = malloc(strlen(auth_token) + 1);
		memcpy(result.signed_data.auth_token, auth_token, strlen(auth_token) + 1);
		result.is_signed = 0;
		result.error = malloc(15);
		memcpy(result.error, "REQUEST_DENIED", 15);
		return &result;
	}

	// simulate the signed data
	SignedData signed_data;
	signed_data.auth_token = malloc(strlen(auth_token) + 1);
	memcpy(signed_data.auth_token, auth_token, strlen(auth_token) + 1);
	// allocate memory for the files and permissions
	signed_data.files_and_perms = malloc(strlen(files_and_perms) * approvals.count);
	memcpy(signed_data.files_and_perms, files_and_perms, strlen(files_and_perms) * approvals.count);

	// encrypt the signed data
	encrypt(&signed_data);

	// simulating the signing process
	result.signed_data = signed_data;
	result.is_signed = 1;
	result.error = malloc(5);
	memcpy(result.error, "NONE", 5);
	return &result;
}

request_access_token_res *
request_access_token_1_svc(request_access_token_args *argp, struct svc_req *rqstp)
{
	static request_access_token_res result;

	// get the user_id
	char *user_id = argp->user_id;
	int user_index = get_user_index(user_id);
	// get the signed data
	SignedData signed_data = argp->signed_data;

	if (argp->is_signed == false)
	{
		// allocate memory for the error
		result.error = malloc(15);
		memcpy(result.error, "REQUEST_DENIED", 15);
		return &result;
	}

	// decrypt the signed data
	decrypt(&signed_data);

	// check if the signed data is valid
	if (strcmp(signed_data.auth_token, (char *)tokens_global[user_index].auth_token) != 0)
	{
		// allocate memory for the error
		result.error = malloc(15);
		memcpy(result.error, "REQUEST_DENIED", 15);
		return &result;
	}

	// generate access token, refresh token and put permissions
	char *access_token = generate_access_token(signed_data.auth_token);
	printf("  AccessToken = %s\n", access_token);
	fflush(stdout);
	tokens_global[user_index].availability = availabilty_global;

	tokens_global[user_index].files_permissions = create_approvals_from_string(signed_data.files_and_perms);

	memcpy(tokens_global[user_index].access_token, access_token, strlen(access_token) + 1);

	if (tokens_global[user_index].automatic_refresh == 1)
	{
		// set the refresh token to the access token
		char *refresh_token = generate_access_token(access_token);
		memcpy(tokens_global[user_index].refresh_token, refresh_token, strlen(refresh_token) + 1);
		printf("  RefreshToken = %s\n", refresh_token);
		fflush(stdout);
		result.refresh_token = malloc(strlen(refresh_token) + 1);
		memcpy(result.refresh_token, refresh_token, strlen(refresh_token) + 1);
	}
	else
	{
		// put garbage in the refresh token
		// char *refresh_token = "refresh_token";
		char *refresh_token = "empty";
		result.refresh_token = malloc(strlen(refresh_token) + 1);
		memcpy(result.refresh_token, refresh_token, strlen(refresh_token) + 1);
	}
	// allocate memory for the access token, refresh token and error
	result.access_token = malloc(strlen(access_token) + 1);
	result.error = malloc(5);

	memcpy(result.access_token, access_token, strlen(access_token) + 1);
	memcpy(result.error, "NONE", 5);
	result.valability = availabilty_global;

	return &result;
}

char **
validate_delegated_action_1_svc(validate_delegated_action_args *argp, struct svc_req *rqstp)
{
	static char *result;

	char *op_type = argp->op_type;
	char *filename = argp->filename;

	char *access_token = argp->access_token;

	// simulating empty token
	if (strcmp(access_token, "empty") == 0)
	{
		result = calloc(MAX_CHAR_SIZE, sizeof(char));
		memcpy(result, "PERMISSION_DENIED", 18);
		printf("DENY (%s,%s,,0)\n", op_type, filename);
		fflush(stdout);
		return &result;
	}
	// search for the token entry
	int index = find_user_id_by_access_token(access_token);
	if (index == -1)
	{
		result = malloc(18);
		memcpy(result, "PERMISSION_DENIED", 18);
		return &result;
	}

	if (tokens_global[index].availability == 0)
	{
		result = malloc(14);
		printf("DENY (%s,%s,,0)\n", op_type, filename);
		fflush(stdout);
		memcpy(result, "TOKEN_EXPIRED", 14);
		return &result;
	}

	// decrement the availability
	tokens_global[index].availability--;

	// check if the file is available in the db
	if (!exists_resource(filename))
	{
		// printf("File does not exist\n");
		result = malloc(19);
		memcpy(result, "RESOURCE_NOT_FOUND", 19);
		printf("DENY (%s,%s,%s,%d)\n", op_type, filename, tokens_global[index].access_token, tokens_global[index].availability);
		fflush(stdout);
		return &result;
	}
	// check if the user has the permissions to access that file
	Approvals approvals = tokens_global[index].files_permissions;

	if (!can_user_access_file(approvals, filename, op_type))
	{
		printf("DENY (%s,%s,%s,%d)\n", op_type, filename, tokens_global[index].access_token, tokens_global[index].availability);
		fflush(stdout);
		result = malloc(24);
		memcpy(result, "OPERATION_NOT_PERMITTED", 24);
		return &result;
	}

	printf("PERMIT (%s,%s,%s,%d)\n", op_type, filename, tokens_global[index].access_token, tokens_global[index].availability);
	fflush(stdout);
	result = malloc(19);
	memcpy(result, "PERMISSION_GRANTED", 19);

	return &result;
}

refresh_access_token_res *
refresh_access_token_1_svc(refresh_access_token_args *argp, struct svc_req *rqstp)
{
	static refresh_access_token_res result;

	int index = find_user_id_by_refresh_token(argp->refresh_token);

	if (index == -1)
	{
		result.error = malloc(22);
		memcpy(result.error, "INVALID_REFRESH_TOKEN ", 22);
		return &result;
	}

	// update the access token and refresh token
	char *access_token = generate_access_token(argp->refresh_token);
	char *refresh_token = generate_access_token(access_token);

	memcpy(tokens_global[index].access_token, access_token, strlen(access_token) + 1);
	memcpy(tokens_global[index].refresh_token, refresh_token, strlen(refresh_token) + 1);
	tokens_global[index].availability = availabilty_global;

	// allocate memory for the access token, refresh token and error
	result.access_token = malloc(strlen(access_token) + 1);
	result.refresh_token = malloc(strlen(refresh_token) + 1);
	result.error = malloc(5);

	memcpy(result.access_token, access_token, strlen(access_token) + 1);
	memcpy(result.refresh_token, refresh_token, strlen(refresh_token) + 1);
	memcpy(result.error, "NONE", 5);
	result.availability = availabilty_global;

	printf("BEGIN %s AUTHZ REFRESH\n", users_global.user_id[index]);
	fflush(stdout);

	printf("  AccessToken = %s\n", access_token);
	fflush(stdout);

	printf("  RefreshToken = %s\n", refresh_token);
	fflush(stdout);

	return &result;
}
