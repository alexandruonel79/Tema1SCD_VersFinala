/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "Oauth.h"
#include "helper_client.h"
#include "helper_client.c"

void auth_prog_1(char *host)
{
	CLIENT *clnt;
	request_auth_res *result_1;
	request_authorization_args request_authorization_1_arg;
	approve_request_token_res *result_2;
	approve_request_token_args approve_request_token_1_arg;
	request_access_token_res *result_3;
	request_access_token_args request_access_token_1_arg;
	char **result_4;
	validate_delegated_action_args validate_delegated_action_1_arg;
	refresh_access_token_res *result_5;
	refresh_access_token_args refresh_access_token_1_arg;

#ifndef DEBUG
	clnt = clnt_create(host, AUTH_PROG, OAUTH, "udp");
	if (clnt == NULL)
	{
		clnt_pcreateerror(host);
		exit(1);
	}
#endif /* DEBUG */

	// set the tokens to empty
	init_clients_info_global();
	// go through all the inputs and parse them
	for (int i = 0; i < inputCollection.count; i++)
	{
		int automatic_refresh = atoi(inputCollection.input[i].argument);
		// getting a new token
		if (strcmp(inputCollection.input[i].operation_type, "REQUEST") == 0)
		{
			// request authorization needs just the user_id and if the user wants with auto renew
			request_authorization_1_arg.user_id = inputCollection.input[i].user_id;
			request_authorization_1_arg.auto_renew = automatic_refresh;
			result_1 = request_authorization_1(&request_authorization_1_arg, clnt);
			if (result_1 == (request_auth_res *)NULL)
			{
				clnt_perror(clnt, "request authorization call failed");
			}
			// if i got an error while requesting auth token, display it
			if (strcmp(result_1->error, "NONE") != 0)
			{
				printf("%s\n", result_1->error);
				continue;
			}

			// got the auth token, now requesting the user permissions
			approve_request_token_1_arg.auth_token = result_1->auth_token;
			result_2 = approve_request_token_1(&approve_request_token_1_arg, clnt);
			if (result_2 == (approve_request_token_res *)NULL)
			{
				clnt_perror(clnt, "request approve call failed");
			}
			// received the user permissions, check if the user signed them
			// the data is encrypted, only the server and user now the secret
			if (result_2->is_signed == 1)
			{
				// if its signed by the user, proceed with requesting the access token
				request_access_token_1_arg.user_id = inputCollection.input[i].user_id;
				request_access_token_1_arg.signed_data = result_2->signed_data;
				request_access_token_1_arg.is_signed = 1;
				result_3 = request_access_token_1(&request_access_token_1_arg, clnt);
				if (result_3 == (request_access_token_res *)NULL)
				{
					clnt_perror(clnt, "request access token call failed");
				}
				/// no errors, the server verified the signature and its good
				// received the access token
				if (strcmp(result_1->error, "NONE") == 0)
				{
					printf("%s", result_1->auth_token);
					printf(" -> %s", result_3->access_token);

					int index = find_index_by_user_id_for_clients_info(inputCollection.input[i].user_id);
					// if its a new client, store it
					if (index == -1)
					{
						clients_info_global[clients_info_counter].access_token = malloc(strlen(result_3->access_token) + 1);
						clients_info_global[clients_info_counter].user_id = malloc(strlen(inputCollection.input[i].user_id) + 1);
						memcpy(clients_info_global[clients_info_counter].access_token, result_3->access_token, strlen(result_3->access_token) + 1);
						memcpy(clients_info_global[clients_info_counter].user_id, inputCollection.input[i].user_id, strlen(inputCollection.input[i].user_id) + 1);
						// set the availability
						clients_info_global[clients_info_counter].availability = result_3->valability + 1;
						// the server sends an 'empty' refresh token if auto renewal is 0
						clients_info_global[clients_info_counter].refresh_token = malloc(strlen(result_3->refresh_token) + 1);
						memcpy(clients_info_global[clients_info_counter].refresh_token, result_3->refresh_token, strlen(result_3->refresh_token) + 1);
						clients_info_global[clients_info_counter].automatic_refresh = automatic_refresh;
						// increment the number of clients
						clients_info_counter++;
					}
					else
					{
						// this is not a new user, maybe he wants different permissions
						memcpy(clients_info_global[index].access_token, result_3->access_token, strlen(result_3->access_token) + 1);
						memcpy(clients_info_global[index].refresh_token, result_3->refresh_token, strlen(result_3->refresh_token) + 1);
						memcpy(clients_info_global[index].user_id, inputCollection.input[i].user_id, strlen(inputCollection.input[i].user_id) + 1);
						clients_info_global[index].availability = result_3->valability + 1;
					}

					if (automatic_refresh == 1)
					{
						printf(",%s\n", result_3->refresh_token);
					}
					else
					{
						printf("\n");
					}
				}
			}
			else
			{
				// the user did not sign, so it's automatically a denied request/error
				printf("%s\n", result_2->error);
			}
		}
		else
		{
			// requested to do an operation on a file
			validate_delegated_action_1_arg.op_type = calloc(strlen(inputCollection.input[i].operation_type) + 1, sizeof(char));
			validate_delegated_action_1_arg.filename = calloc(strlen(inputCollection.input[i].argument) + 1, sizeof(char));

			int user_index = find_index_by_user_id_for_clients_info(inputCollection.input[i].user_id);
			// requesting access to a file but the user is not stored, does not have an access token
			if (user_index == -1)
			{
				validate_delegated_action_1_arg.op_type = calloc(strlen(inputCollection.input[i].operation_type) + 1, sizeof(char));
				memcpy(validate_delegated_action_1_arg.op_type, inputCollection.input[i].operation_type, strlen(inputCollection.input[i].operation_type));

				memcpy(validate_delegated_action_1_arg.filename, inputCollection.input[i].argument, strlen(inputCollection.input[i].argument) + 1);
				validate_delegated_action_1_arg.access_token = calloc(16, sizeof(char));
				memcpy(validate_delegated_action_1_arg.access_token, "empty", 6);
				result_4 = validate_delegated_action_1(&validate_delegated_action_1_arg, clnt);
				if (result_4 == (char **)NULL)
				{
					clnt_perror(clnt, "validate delegated action call failed");
				}
				printf("%s\n", *result_4);
				continue;
			}

			// decrease availability no matter the result
			clients_info_global[user_index].availability--;
			// for the users with automatic renewal, check if they still have availability, and if not request a new token
			// using the refresh token
			if (clients_info_global[user_index].automatic_refresh == 1 && clients_info_global[user_index].availability == 0)
			{
				// send only the refresh token
				refresh_access_token_1_arg.refresh_token = malloc(strlen(clients_info_global[user_index].refresh_token) + 1);
				refresh_access_token_1_arg.refresh_token = clients_info_global[user_index].refresh_token;

				result_5 = refresh_access_token_1(&refresh_access_token_1_arg, clnt);
				if (result_5 == (refresh_access_token_res *)NULL)
				{
					clnt_perror(clnt, "refresh access token call failed");
				}

				if (strncmp(result_5->error, "NONE", 4) == 0)
				{
					memcpy(clients_info_global[user_index].access_token, result_5->access_token, strlen(result_5->access_token) + 1);
					memcpy(clients_info_global[user_index].refresh_token, result_5->refresh_token, strlen(result_5->refresh_token) + 1);
					clients_info_global[user_index].availability = result_5->availability;
				}
				else
				{
					printf("%s\n", result_5->error);
					continue;
				}
			}

			validate_delegated_action_1_arg.access_token = malloc(strlen(clients_info_global[user_index].access_token) + 1);
			memcpy(validate_delegated_action_1_arg.op_type, inputCollection.input[i].operation_type, strlen(inputCollection.input[i].operation_type) + 1);
			memcpy(validate_delegated_action_1_arg.filename, inputCollection.input[i].argument, strlen(inputCollection.input[i].argument) + 1);
			memcpy(validate_delegated_action_1_arg.access_token, clients_info_global[user_index].access_token, strlen(clients_info_global[user_index].access_token) + 1);

			result_4 = validate_delegated_action_1(&validate_delegated_action_1_arg, clnt);
			if (result_4 == (char **)NULL)
			{
				clnt_perror(clnt, "validate delegated action call failed");
			}

			printf("%s\n", *result_4);
		}
	}
#ifndef DEBUG
	clnt_destroy(clnt);
#endif /* DEBUG */
}

int main(int argc, char *argv[])
{
	char *host;

	if (argc < 3)
	{
		printf("usage: %s server_host fisier_operatii\n", argv[0]);
		exit(1);
	}
	host = argv[1];
	inputCollection = read_input_collection(argv[2]);
	auth_prog_1(host);
	exit(0);
}
